package com.example.app.utils.factorial;

/**
 * 動的計画法
 * 
 * @since 2024/11/24
 * @author koji kawazu
 */
public class FibonacciDP {

	/**
	 * 動的計画法（ボトムアップアプローチ）
	 *
	 * - メモリ制約が厳しい場合: - メモ化では全ての部分問題の結果を保存する必要がありますが、
	 * 動的計画法のボトムアップアプローチでは、計算に必要な直前の数値（フィボナッチ数列の場合、 直前の2つの数）だけを保持すれば良いため、空間計算量を O(1)
	 * に抑えることが可能です。 - メモリの使用を最小限にしたい場合、メモ化よりもボトムアップの動的計画法が優れています。
	 *
	 * - 再帰のオーバーヘッドを避けたい場合: - メモ化は再帰をベースにしているため、再帰呼び出しごとにスタックを使います。
	 * 入力が非常に大きくなった場合、再帰の深さも増し、スタックオーバーフローを引き起こす可能性があります。 -
	 * 再帰を使わないボトムアップアプローチではループを使って順に計算するため、 再帰のオーバーヘッドがなく、スタックオーバーフローの心配もありません。
	 *
	 * - 計算の順序がわかっている場合: - 計算の順序が明確に決まっており、順に計算していく方が自然な場合には、
	 * ボトムアップのアプローチが適しています。フィボナッチ数列のように、計算が直前の値から順に決定される場合には、
	 * ボトムアップで全ての部分問題を解決してから最終的な答えを得るのが効率的です。
	 */

	/**
	 * 動的計画法を使用したフィボナッチ数列の計算 ボトムアップアプローチで効率的にn番目のフィボナッチ数を求める
	 * 
	 * @param n フィボナッチ数列のn番目の値
	 * @return n番目のフィボナッチ数
	 */
	public static int fibonacci(int n) {
		if (n <= 1) {
			return n;
		}

		// 直前の2つの値を保持する変数
		int prev1 = 0, prev2 = 1;
		int current = 0;

		// nまでのフィボナッチ数を計算
		for (int i = 2; i <= n; i++) {
			current = prev1 + prev2;
			prev1 = prev2;
			prev2 = current;
		}

		return current;
	}

	/**
	 * main関数
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		int n = 40;
		System.out.println(n + " 番目のフィボナッチ数: " + fibonacci(n));
	}
}
